## 需求拆分原则

- 单个迭代不宜太大
- 拆分出的需求是可交付的, 能够形成功能闭环, 不能把完整的流程切开
- 有成本意识, 用20%的精力做有80%价值的事 —— 不能把80%的精力用在只有20%价值的事上
- 有预期的价值体现 —— 完成这个需求能带来什么价值



> 类比生物体, 一个大型项目(个体)划分成多个系统.  
>
> 系统就是利用框架+库+业务形成的具有一定功能的工具. 达到分工协作，层次分明，出了问题也可以很容易地找到问题所在点。



## 提炼核心需求

最重要的是完成什么功能? —— 卖东西 —— 用户能浏览、加购物车、下单、支付、查看订单、用户账号管理




## 架构设计

#### 分层架构

目的: 解耦

常用: MVC、MVVM

改变其中一个层级时, 只需要保证此层级的接口不变, 里面的实现方式可以变



> 类比系统中的器官
>
> 器官是由多种组织构成的能行使一定功能的结构单位。器官是生物体中自己具有一定功能，承担生物体一 定的工作，是生物结构层次中比组织高一级的层次。器官由各种组织构成。
>
> 器官中的组织可以被替换，而脚手架中的库也可以被取代。如果iview-project想把webpack换成其他构建工具，也要调研一下是否会发生“移植排斥”，“排斥反映”的严重程度是否能够接受，移植完成后，也要对新组织慢慢作出一些“修改”，使其能与原器官相适配。



#### 模块化  

目的: 解耦、并行开发

常用: AMD、CMD、**CommonJS**、ES6(与CommonJS类似, 目前兼容性不好)

逻辑层的模块和服务器进行数据交互, 数据交互的方法划分为Service模块, 是为数据层.

所有的数据交换都得由数据层进行, 不允许业务模块直接和服务器进行跨层对接



## 技术选型

**软件过程**  瀑布模型、螺旋模型、敏捷开发

**前后端分离方式**  

**构建工具**  

**框架**  

**版本控制**  

**发布方式**  



## 接口文档——范式

先写接口文档, 再写代码; 有接口改动, 记得更新文档



### 模版 —— 接口名称

**/product/.do**  —— 接口地址

> request —— 请求信息

```
k
```

> response —— 响应信息

**success**  

```json
{
    "status": 0, 		—— 接口状态, 0成功、1失败、10未登录
    "data": { 			—— 接口数据
        "id": 2,
        "name": "oppo R8"
    }
}
```

**fail**  

```json
{
    "status": 1, 		
    "msg": "该商品已下架或删除"   —— 接口错误信息
}
```

